<%- include("partials/head.ejs") %>

<h1 class="titulo-login"> <%= about %> </h1>

<!-- Ahora los datos no los enviamos con fetch, sino con <form> -> Necesitamos parsear estos datos (no json) en nuestra aplicacion-->
<form id="login-formulario" class="productos-formulario-amplio login-formulario" action="/login" method="POST" autocomplete="off">

    <label class="texto-id" for="emailUsuario">Email</label>
    <input class="input-formulario" type="email" name="correo" id="emailUsuario" required>

    <label class="texto-id" for="passwordUsuario">Password</label>
    <input class="input-formulario" type="password" name="password" id="passwordUsuario" required>
    
    <div class="botones-login">
        <input class="boton" type="submit" value="Login">
        <input class="boton" type="button" id="acceso" value="Acceso rápido">
    </div>
</form>

<!-- Amosamos o mensaxe de erro do endpoint -->
<% if (typeof error !== "undefined") { %>
    <div class="div-mensaje-error">
        <li class="mensaje-error">
                <strong>Error:</strong>
                <span><%= error %></span>
        </li>
    </div>
<% } %>

<!-- Enviando una peticion POST con <form>
- Express no sabe cómo leer el cuerpo de la petición POST si no tienes un middleware de parsing.

- En el caso de un formulario HTML clásico (method="POST"), el navegador envía los datos como application/x-www-form-urlencoded por defecto.

- Si no tienes el parser de urlencoded, req.body será undefined.
Envía datos como application/x-www-form-urlencoded → necesita express.urlencoded.-->

<script>
    let emailUser = document.getElementById("emailUsuario");
    let passwordUser = document.getElementById("passwordUsuario");

    let acceso_rapido = document.getElementById("acceso");
    acceso_rapido.addEventListener("click", () => {
        emailUser.value = "test@test.com";
        passwordUser.value = "test";
    });
</script>

<%- include("partials/footer.ejs") %>